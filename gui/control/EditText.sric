import sric::*;
import waseGraphics::*;

struct Caret
{
  var visible :Bool = false;
  
  // offset of line
  var byteOffset :Int = 0;
  protected var posXOffset :Int = -1;
}


struct EditText : Widget
{
  readonly var text : String = "";
  var onTextChange : fun(old: &String, text: &String);

  //@Transient
  protected var lines: DArray$<String>;

  var hint :String = "";

  //@Transient
  var caret : Caret;

  //@Transient
  private var timer : own*? Timer;

  //@Transient
  protected var host: own*? TextInput;

  readonly var inputType :Int = 1;
  var editable :Bool= true;

  fun setInputType(t: Int) { inputType = t; }
  
  fun setText(t: String, fire: Bool = true)
  {
      if (fire && onTextChange != null) {
        onTextChange(text, t);
      }
      text = move t;
      caret.byteOffset = text.size();
      if (t.contains("\n")) {
        lines = t.split("\n");
      }
      else {
        lines.clear();
      }
      if (fire) {
        eventListeners.fire(EventType::TextChanged, this);
      }
  }

  fun isPassword(): Bool { return inputType == TextInput::inputTypePassword; }

  fun new()
  {
    //this.layout.width = font.height * 10
    this.padding = Insets { .init(15, 30, 15, 30); };
    focusable = true;
    style = "EditText";
  }

  protected override fun setFocusState(f: Bool) {
      super.setFocusState(f);
      var focused = f;
      if (focused)
      {
        //var self_ = this;
        this.host = this.getRootView().host().textInput(this.inputType);
        if (this.host != null) {
          this.host.onTextChange = fun(text: raw*const Int8) {
              this.setText(text, false);
              //return move text;
          };
          this.host.onKeyAction = fun(text: raw*const Int8) {
              this.setText(text, false);
          };
          this.updateHost();
        }
        else {
          this.startCaret();
        }
      }
      else
      {
        this.stopCaret();
        this.caret.visible = false;
        if (this.host != null) {
          this.host.close();
          this.host = null;
        }
        this.repaint();
      }
  }

  private fun updateHost() {
    if (host == null) return;
    var lineNum = lines.size();
    host.setType(lineNum, editable);
    
    var view = Window::getCur().view() as *WinView;
    var s = 1/view.inverseScreenScale;
    var p = this.posOnWindow();
    var x = ((p.x + padding.left) * s) as Int;
    var y = ((p.y + padding.top) * s) as Int;
    var w = (contentWidth() * s) as Int;
    var h = (contentHeight() * s) as Int;
    host.setPos(x, y, w, h);

    var style = getStyle();
    var color = style.fontColor;
    var bgColor = style.background;
    host.setStyle(style.font, style.fontSize*s, color, bgColor);
    //host.setStyle(font, Color.black, Color(0xe0e0e0))
    host.setText(text.c_str());
    host.focus();
  }

  protected override fun layoutChildren(g: &Graphics,  force: Bool) {
    super.layoutChildren(g, force);
    updateHost();
  }

  protected override fun prefContentSize(g: &Graphics, hintsWidth : Int = -1, hintsHeight : Int = -1): Size {
    g.setFont(getStyle().font);
    g.setFontSize(getStyle().fontSize);
    var metric: FontMetrics;
    g.fontMetrics(metric);
    var w = g.textWidth(text.c_str(), text.size());
    var h = metric.height;

    if (lines.size() > 0) {
        h *= lines.size();
    }
    return Size{.w=w as Int; .h = h as Int;};
  }

  private fun startCaret()
  {
    if (timer != null && !timer.canceled) return;

    //show caret
    caret.visible = true;
    repaint();

    //var self_ = this;
    //caret blink
    if (timer == null) {
        timer = new Timer;
    }
    timer.init(500, fun() {
      if (this.focused())
      {
        caret.visible = !caret.visible;
        this.repaint();
      }
    });
    timer.start();
  }

  private fun stopCaret() {
    if (timer != null)
        timer.cancel();
  }


  override fun keyEvent( e: &KeyEvent)
  {

    if (e.type == KeyEventType::Press) {
        switch (e.key) {
        case Key::Backspace:
          if (text.size() > 0)
          {
            if (caret.byteOffset >= text.size()) {
              text = text.substr(0, text.size()-1);
              caret.byteOffset = text.size();
            }
            else {
              var n = 0;
              text.getCharAt(caret.byteOffset, &n);
              text = text.substr(0, caret.byteOffset-n) + text.substr(caret.byteOffset, text.size()-caret.byteOffset);
              caret.byteOffset = caret.byteOffset-n;
            }
            
          }
        case Key::Right:
          if (caret.byteOffset < text.size()) {
            var n = 0;
            text.getCharAt(caret.byteOffset, &n);
            caret.byteOffset += n;
          }
        case Key::Left:
          var n = caret.byteOffset;
          if (n > 0 && n <= text.size()) {
            n = text.preCharPos(n);
            if (n < 0) n = 0;
            caret.byteOffset = n;
          }
        }
        caret.visible = true;
        repaint();
        return;
    }
    else if (e.type == KeyEventType::Typed) {
      if (e.keyChar < 32) return;

      if (caret.byteOffset >= text.size()) {
        text = text + String::fromChar(e.keyChar);
        caret.byteOffset = text.size();
      }
      else {
        var str = String::fromChar(e.keyChar);
        text = text.substr(0, caret.byteOffset) +str+ text.substr(caret.byteOffset, text.size()-caret.byteOffset);
        caret.byteOffset = caret.byteOffset+str.size();
      }
      caret.visible = true;
      repaint();
    }
  }

  fun makePasswordText() : String {
    var buf: String;
    for (var i=0; i<text.size(); ++i) {
      buf.add("*");
    }
    return buf;
  }

  protected override fun doPaint(clip: &Rect, g: &Graphics) {
    if (caret.posXOffset != -1) {
      var style = getStyle();
      g.setFont(style.font);
      g.setFontSize(style.fontSize);
      if (isPassword()) {
        caret.byteOffset = posXOffsetToByte(g, caret.posXOffset, makePasswordText());
      }
      else {
        caret.byteOffset = posXOffsetToByte(g, caret.posXOffset, text);
      }
      caret.posXOffset = -1;
    }
    super.doPaint(clip, g);
  }

  protected fun posXOffsetToByte(g: &Graphics, posXOffset: Int, line: const &String): Int {
    if (posXOffset <= 0) {
      return 0;
    }
    var start = 0;
    var end = 0;
    while (end < line.size()) {
        //t := line[start..<end];
        var lw = 0f;
        unsafe {
            lw = g.textWidth(line.c_str() + start, end-start);
        }
        if (lw > posXOffset && (end-1>start)) {
            end = end - 1;
            break;
        }

        end = line.nextCharPos(end);
    }
    return end;
  }

  protected override fun gestureEvent( e: &GestureEvent)
  {
    if (e.type == GestureEvent::click)
    {
      focus();
      e.consumed = true;

      var posXOffset = e.relativeX - this.x - this.paddingLeft();
      this.caret.posXOffset = posXOffset;
      caret.visible = true;
      repaint();
    }
  }
}