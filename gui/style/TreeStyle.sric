import sric::*;
import waseGraphics::*;

virtual struct TreeItemStyle : WidgetStyle
{
  var dropColor : Color = Color { .rgba = 0x807455ff; };
  var hoverColor : Color = Color { .rgba = 0xf8f8f8ff; };
  var arrowSize: Int = 10;
  var arrowLineWidth: Int = 1;
  var indent :Int= 40;
  
  fun new() {
    background = Color { .rgba = 0xeff8efff; };
  }
  
  override fun doPaint(widget: * Widget , g:& Graphics)
  {
    var item = widget as * TreeItem;
    g.setColor(color);
    //var lWidth = (lineWidth);
    //g.lineWidth(lWidth);

    var top = widget.paddingTop();
    var left = widget.paddingLeft() + item.level * indent;
    var bottom = top + widget.contentHeight();
    var right =  left + widget.contentWidth();
    var vcenter = (top + bottom) / 2;

    if (item.isHover) {
      g.setColor(hoverColor);
      g.fillRect(0, 0, widget.width, widget.height);
    }

    if (item.isSelected()) {
      g.setColor(background);
      g.fillRect(0, 0, widget.width, widget.height);
    }

    if (item.isDragDropDst()) {
      g.setColor(dropColor);
      g.fillRect(0, 0, widget.width, widget.height);
    }

    if (item.hasChildren()) {
      g.setColor(color);
      drawArrow(g, left+arrowSize, vcenter, item);
    }

    if (item.text.size() > 0) {
      drawText(widget, g, item.text, Align::Begin, Align::Center, left+arrowSize*2+20);
    }
  }

  fun drawArrow(g:& Graphics, cx: Float32, cy: Float32, item: *TreeItem) {
    g.lineWidth(arrowLineWidth);
    var pa = g.beginPath();
    var s = arrowSize * 0.5;
    if (item.expanded) {
      //draw v
      pa.moveTo(cx - s*2, cy-s);
      pa.lineTo(cx, cy+s);
      pa.lineTo(cx + s*2, cy-s);
    }
    else {
      //draw >
      pa.moveTo(cx - s, cy-s*2);
      pa.lineTo(cx + s, cy);
      pa.lineTo(cx - s, cy+s*2);
    }
    //pa.close();
    g.drawPath(pa);
  }
}