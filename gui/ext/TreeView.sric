import sric::*;
import waseGraphics::*;
import cstd::*;

struct TreeView : VBox
{
  /**
  ** Backing data model of tree.
  **/
  //@Transient
  var model : own*? TreeModel;
  
  //@Transient
  readonly var selectedItem: Int = -1;
  //@Transient
  protected var dragDropItem: Int = -1;
  //@Transient
  private var draging :Bool= false;

  var onSelect: fun(t:Int, event:Int);
  var onDragDrop: fun(f:Int, t:Int);

  fun setModel(t: own*TreeModel) {
    model = move t;
    init();
  }

  fun select(id: Int) {
    selectedItem = id;
    this.repaint();
  }

  fun new()
  {
    dragAware = true;
  }

  private fun removeRange(begin: Int, end: Int) {
    var root = getRootView();
    for (var i = end-1; i>=begin; --i) {
      if (root != null) {
          children[i].onRemove(root);
      }
      children[i].setParent(null);
      this.children.removeAt(i);
    }
  }

  fun expanded(index: Int)
  {
    var item: * TreeItem = getChild(index) as *TreeItem;
    if (!item.hasChildren()) return;

    if (item.expanded)
    {
      //close
      //var i = indexSame(item) + 1;
      var start = index + 1;
      var p = index + 1;
      for (var n = children.size(); p<n; ++p)
      {
        var child: * TreeItem = getChild(p) as *TreeItem;
        if (child.level <= item.level) break;
      }
      item.expanded = !item.expanded;
      removeRange(start, p);
      relayout();
      return;
    }
    else
    {
      //expand
      //var i = indexSame(item);
      item.expanded = !item.expanded;

      var nlist = item.getChildren();
      for (var i = 0; i< nlist.size(); ++i) {
        nlist[i].setParent(this);
      }
      children.insertAll(index+1, move nlist);
      relayout();
      return;
    }
  }

  /**
  ** Update the entire tree's contents from the model.
  **/
  private fun init()
  {
    this.removeAll();
    var roots = model.roots();
    for (var i=0; i<roots.size(); ++i) {
        var subNode:Int = roots[i];
        var item = new TreeItem { .init(this, subNode, 0); };
        this.add(move item);
    }
    relayout();
  }
  
  protected override fun motionEvent( e: & MotionEvent) {
    super.motionEvent(e);
    
    if (e.type == MotionEventType::Press) {
        var i = findItemAt(e.relativeY);
        if (i != -1) {
          var item: * TreeItem = getChild(i) as *TreeItem;
          if (selectedItem == item.node) {
            draging = true;
            dragDropItem = -1;
            //printf("start draging\n");
          }
        }
    }
  }
  
  private fun findItemAt(eventY:Int ): Int {
    var relativeY = eventY - this.y;
    for (var i = 0; i<this.childrenNum(); ++i)
    {
      if (this.children[i].y < relativeY && this.children[i].y + this.children[i].height > relativeY) {
        return i;
      }
    }
    return -1;
  }
  
  protected override fun onDrag( e:&GestureEvent) {
    if (e.type == GestureEvent::drag) {
      if (draging) {
        var i = findItemAt(e.relativeY);
        dragDropItem = i == -1 ? -1 : (getChild(i) as *TreeItem).node;
        //printf("dragDropItem: %d\n", dragDropItem);
        e.consumed = true;
        this.repaint();
      }
    }
    else if (e.type == GestureEvent::drop) {
      draging = false;
      var i = findItemAt(e.relativeY);
      dragDropItem = i == -1 ? -1 : (getChild(i) as *TreeItem).node;
      //printf("drag end: %d\n", dragDropItem);
      if (selectedItem != -1 && dragDropItem != -1 && selectedItem != dragDropItem) {
        if (onDragDrop != null)
            onDragDrop(selectedItem, dragDropItem);
      }
      dragDropItem = -1;
      this.relayout();
      e.consumed = true;
    }
  }

  fun clearSelection() {
    // for (var i = 0; i<this.childrenNum(); ++i) {
    //   var child: * TreeItem = getChild(i) as *TreeItem;
    //   if (child.isSelected) {
    //     child.isSelected = false;
    //     break;
    //   }
    // }
    this.selectedItem = -1;
  }

  protected override fun gestureEvent(e: &GestureEvent )
  {
    super.gestureEvent(e);
    if (e.consumed) return;

    if ((e.type == GestureEvent::click || e.type == GestureEvent::doubleClick) && e.button == ButtonType::Left)
    {
      var i = findItemAt(e.relativeY);
      selectedItem = i == -1 ? -1 : (getChild(i) as *TreeItem).node;
      if (i != -1)
      {
        //clearSelection();
        //(getChild(i) as *TreeItem).isSelected = true;
        expanded(i);
        this.relayout();
        e.consumed = true;
      }
      if (onSelect != null)
        onSelect(selectedItem, e.type);
      
      dragDropItem = -1;
    }
    
    if (e.consumed) return;
    if (!draging) {
      super.gestureEvent(e);
      return;
    }
  }
}


struct TreeItem : Pane
{
  //@Transient
  private var tree: *? TreeView;

  var node: Int64;
  var parentItem: *? TreeItem;

  var level : Int = 0;
  var expanded : Bool = false;
  var text: String;
  var isHover : Bool = false;

  fun init( tree: * TreeView, node: Int64,  level: Int)
  {
    this.tree = tree;
    this.node = node;
    this.level = level;
    this.style = "TreeItem";
    this.layout.height = Layout::wrapContent;
    this.layout.width = Layout::matchParent;
    this.padding.top = 4;
    this.padding.bottom = 4;
    this.padding.left = 4;
    this.padding.right = 4;
    tree.model.initView(this);
    //this.layout.offsetX = tree.indent * level;
    mouseAware = true;
  }

  
  override fun mouseExit() {
    isHover = false;
    repaint();
  }

  override fun mouseEnter() {
    isHover = true;
    repaint();
  }

  fun isDragDropDst(): Bool {
    return this.tree.dragDropItem == this.node;
  }

  fun isSelected(): Bool {
    return this.tree.selectedItem == this.node;
  }

  fun hasChildren(): Bool { return tree.model.hasChildren(node); }

  fun getChildren(): DArray$<own* Widget>
  {
    var list : DArray$<own* Widget>;
    var children = tree.model.children(node);
    for (var i=0; i<children.size(); ++i)
    {
      var subNode: Int64 = children[i];
      var item = new TreeItem { .init(tree, subNode, level+1); .parentItem = this; };
      list.add(move item);
    }
    return list;
  }

  protected override fun prefContentSize(g: &Graphics, hintsWidth : Int = -1, hintsHeight : Int = -1): Size {
      g.setFont(getStyle().font);
      g.setFontSize(getStyle().fontSize);
      var metric: FontMetrics;
      g.fontMetrics(metric);
      var w = g.textWidth(text.c_str(), text.size())+3;
      var h = metric.height;
      var sizeCache = Size{.w=w as Int; .h = h as Int;};
      return sizeCache;
  }
}


virtual struct TreeModel
{
  var checkable : Bool = true;

  virtual fun roots(): DArray$<Int64> {
    var p : DArray$<Int64>;
    return p;
  }

  virtual fun initView(view: *TreeItem) {
    view.text = String::format("%d", view.node);
    if (checkable) {
      view.add(new ToggleButton {
        .setText(""); .setStyle("checkBox");
        .layout.width = Layout::wrapContent;
        .layout.height = Layout::matchParent;
        .layout.hAlign = Align::End;
      });
    }
  }

  virtual fun hasChildren(node: Int64): Bool { return !children(node).isEmpty(); }

  virtual fun children(node: Int64): DArray$<Int64> {
    var p : DArray$<Int64>;
    return p;
  }
}
